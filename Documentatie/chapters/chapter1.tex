\lstset{frame=tb,
	language=C++,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny,
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3}

\chapter{Verificarea formală a problemei}


\section{Particularități ale problemei alese}
    \subsection{Implementarea algoritmului}
    Implementarea algoritmului propriu-zis care rezolvă problema a fost primul și cel mai ușor pas.\par
    Am început prin crearea unei bucle care la fiecare pas alegea bancnota optimă, o adăuga în secvența de 
    bancnote considerată soluție și o scădea din sumă, tipic metodei Greedy.
    \begin{lstlisting}
    var rest:= sum;
    solution:= [0, 0, 0, 0, 0, 0];
    while (0 < rest)
        decreases rest 
        {
        index:= maxBanknote(rest);
        var banknote:= power(2, index);
        solution:= addValueToIndex(solution,1,index);
        rest:= rest - banknote;
    }
    \end{lstlisting}
    Acest algoritm era suficient pentru a rezolva problema, dar nu era suficient pentru a demonstra că soluția produsă este optimă.
    Considerăm o soluție optimă soluția de cost minim, costul fiind numărul de bancnote.
    \subsection{Observații}
    Datorită bancnotelor care sunt puteri ale lui 2, dacă avem mai mult de o bancnotă de valoare mai mică decât 32,
    putem înlocui 2 bancnote de acea valoare cu o bancnotă de valoarea următoare și am obține o soluție cu cost mai mic.
    o soluție care conține oricare 2 bancnote x cu valoare mai mică 
    decât 32 poate fi înlocuită cu o soluție care conține o următoare bancnotă y   și 
    //Orice soluție are s[i] <= 1, 0 <= i <= 4




\section{Demonstrarea optimalității}
    \subsection{Pașii verificării}
    //fa un desen schematic
    //explica cam cum apeleaza cine pe cine pt un caz general i 

    \subsection{Detalii de implementare}
    //exemple cod pentru cele mai importante: exchange argument32, banknoteMaxim32, maxBanknote , metoda principala

\section{Posibile îmbunătățiri ???}


